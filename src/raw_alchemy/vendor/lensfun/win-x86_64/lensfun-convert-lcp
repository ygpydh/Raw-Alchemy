#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""This program reads Adobe LCP files and converts their content to one Lensfun
XML file.  It was tested against the LCP files shipped with “Adobe DNG
Converter 9.0” although it should work with other sets of LCP files, too.

This program assumes that one LCP file contains the data of exactly one lens.

It writes a single XML output file, by default into the personal DB directory.
While this directory has highest priority, note that other files in this
directory – albeit highly unlikely – might contain entries that override data
in that XML file.
"""

import os, argparse, sys, re, copy, glob, multiprocessing
from xml.etree import ElementTree

# Top-level definitions for multiprocessing compatibility on Windows

def child_without_attributes(parent, name):
    """Return the first child element that doesn't have attributes.  This is used
    e.g. for the ``<model>`` tag in order to get the version without the
    ``lang`` attribute.
    """
    for child in parent.findall(name):
        if not list(child.attrib.keys()):
            return child

class LensfunCamera:
    """One camera entry in Lensfun's database.  It is used to derive cropfactors of
    LCP entries from them, and the mounts of compact cameras.
    """
    def __init__(self, maker, model):
        self.maker, self.model = maker, model
        self.mount = None
        self.cropfactor = None

class LensfunLens:
    """One ``<lens>`` entry in Lensfun's database.
    """
    model_name_token_regex = re.compile(r"[0-9][0-9.]*|\s+|[^\w\s]+|[^\W\d_]+")
    model_name_number_regex = re.compile(r"\s+((AB|[ABCGS])\d{2,3}([ENPS]|EM)?|272E[ENPS]|F004[ENS]?|o77)(?=\s|$)")
    model_name_f_regex = re.compile(r"(?<=\s)F(?=\d)")
    model_name_fixes = {
        "TAMRON 18-270mm F/3.5-6.3 DiII PZD B008S": "Tamron AF 18-270mm f/3.5-6.3 Di II VC PZD",
        "SIGMA 18-35mm F1.8 DC HSM A013": "Sigma 18-35mm f/1.8 DC HSM [A]",
        "SIGMA 30mm F1.4 DC HSM A013": "Sigma 30mm f/1.4 EX DC HSM",
        "Sony DT 55-200mm F4-5.6 SAM": "Sony AF DT 55-200mm f/4-5.6 SAM",
        "Canon EF 135mm f/2 L USM": "Canon EF 135mm f/2.0L USM",
        "Nikon AF NIKKOR 35mm f/2D": "Nikon AF Nikkor 35mm f/2.0D",
        "Nikon AF-S DX DX NIKKOR 18-300mm f/3.5-6.3G ED VR": "Nikon AF-S DX Nikkor 18-300mm f/3.5-6.3G ED VR",
        "Nikon NIKKOR 50mm f/1.2 AIS": "Nikon AI-S Nikkor 50mm f/1.2",
        "SIGMA 12-24mm F4.5-5.6 EX DG ASPHERICAL HSM": "Sigma 12-24mm f/4.5-5.6 EX DG USM",
        "SIGMA 17-70mm F2.8-4.5 DC MACRO HSM": "Sigma 17-70mm f/2.8-4.5 DC Macro",
        "SIGMA 24-105mm F4 DG OS HSM A013": "Sigma 24-105mm f/4.0 DG OS HSM [A]",
        "SIGMA 8mm F3.5 EX DG CIRCULAR FISHEYE": "Sigma 8mm f/3.5 EX DG Circular",
        "TAMRON SP AF 28-75mm F2.8 XR Di": "Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical (IF) Macro",
        "TAMRON XR DiII 18-200mm F3.5-6.3": "Tamron AF 18-200mm f/3.5-6.3 XR Di II LD Aspherical (IF) Macro",
        "Tokina AT-X 124 PRO DX 12-24mm F4(IF)": "Tokina 12-24mm f/4 AT-X 124 AF Pro DX",
        "smc PENTAX-DA 10-17mm F3.5-4.5 ED [IF] Fisheye zoom": "smc Pentax-DA Fish-Eye 10-17mm f/3.5-4.5 ED IF"}
    uppercase_token_regex = re.compile(r"\b(SIGMA|TAMRON|ELMAR|SUMMILUX|SUMMICRON|SUMMARIT|ELMARIT|VARIO|SUPER|"
                                    r"TRI|NOCTILUX|TELYT|ASPH|PRO|MACRO|"
                                    r"ASPHERICAL|CIRCULAR|DIAGONAL|FISHEYE|PENTAX)\b")

    def __init__(self, element):
        self.element = element
        model = child_without_attributes(element, "model").text
        self.normalized_model = self.normalize_lens_model_name(model)
        self.cropfactor = float(element.find("cropfactor").text)
        first_mount = element.find("mount").text
        if first_mount[0].islower():
            self.fixed_lens_mount = first_mount
        else:
            self.fixed_lens_mount = None
        self.chdk = "chdk" in model.lower()

    @staticmethod
    def normalize_lens_model_name(name):
        return tuple(token for token in LensfunLens.model_name_token_regex.findall(name.lower())
                    if token != "f" and not token.isspace() and
                    (len(token) > 1 or token.isalnum() or token in "*+"))

    @classmethod
    def sanitize_lcp_lens_model_name(cls, name):
        try:
            return cls.model_name_fixes[name]
        except KeyError:
            result = []
            previous_match = None
            for match in cls.uppercase_token_regex.finditer(name):
                result.append(name[previous_match and previous_match.end() or 0:match.start()])
                result.append(match.group(0).capitalize())
                previous_match = match
            result.append(name[previous_match and previous_match.end() or 0:])
            name = "".join(result)
            name = name.replace("DiII", "Di II")
            name = name.replace("Leica ", "")
            name = name.replace("Voigtlander", "Voigtländer")
            name = cls.model_name_number_regex.sub("", name)
            name = cls.model_name_f_regex.sub("f/", name)
            return name

    def matches(self, names, cropfactor, fixed_lens_mount):
        if self.fixed_lens_mount and fixed_lens_mount == self.fixed_lens_mount and not self.chdk:
            return (1000, 0)
        scores = []
        for name in names:
            normalized_model = list(self.normalized_model)
            try:
                for token in self.normalize_lens_model_name(name):
                    normalized_model.remove(token)
            except ValueError:
                continue
            unmatched_tokens = len(normalized_model)
            if unmatched_tokens < 4:
                scores.append(10 - unmatched_tokens)
                break
        else:
            return (-1000, 0)
        cropfactor_ratio = cropfactor / self.cropfactor
        if not 0.96 < cropfactor_ratio < 1.041:
            return (-1000, 0)
        else:
            scores.append(10 - 100 * abs(1 - cropfactor_ratio))
        return tuple(scores)

class FieldNotFoundError(Exception):
    pass

class NoLCPDataUsed(Exception):
    pass

class NoFieldDefault:
    pass

# Important LCP namespaces
camera_ns = "{http://ns.adobe.com/photoshop/1.0/camera-profile}"
rdf_ns = "{http://www.w3.org/1999/02/22-rdf-syntax-ns#}"
# This regex identifies garbage in the <Lens> tag in the LCP file.
unusable_lens_name_regex = re.compile(r"[-0-9.]+\s*mm(\s*f/?[-0-9.]+)?|Sigma Lens$", re.IGNORECASE)
# This regex is used for finding a focal length in a string.
focal_length_regex = re.compile(r"([0-9.]+)\s*mm\b", re.IGNORECASE)

# Global data for worker processes, populated by init_worker
g_lensfun_cameras = None
g_lensfun_lenses = None
g_args = None

def init_worker(lensfun_cameras_arg, lensfun_lenses_arg, args_arg):
    """Initializer for worker processes."""
    global g_lensfun_cameras, g_lensfun_lenses, g_args
    g_lensfun_cameras = lensfun_cameras_arg
    g_lensfun_lenses = lensfun_lenses_arg
    g_args = args_arg

class LCPLens:
    """An entry in the LCP database.  It is identical with a single LCP file."""
    compact_cameras = []

    def __init__(self, filepath):
        tree = ElementTree.parse(filepath)
        self.old_format = bool(
            tree.findall(".//{http://ns.adobe.com/photoshop/1.0/camera-profile}Make"))
        self.calibration_entries = [self.get_description_element_maybe(entry) for entry in tree.getroot()[0][0][0][0]]
        self.read_first_entry()
        self.fix_focal_lengths()
        self.xml_element = self.xml_element()

    def get_description_element_maybe(self, element):
        if self.old_format:
            return element
        description = element.find(rdf_ns + "Description")
        if description is None:
            return element
        else:
            return description

    def read_field(self, element, field_name, default=NoFieldDefault):
        try:
            if self.old_format:
                return element.find(camera_ns + field_name).text
            else:
                return element.attrib[camera_ns + field_name]
        except (KeyError, AttributeError):
            if default is not NoFieldDefault:
                return default
            raise FieldNotFoundError(field_name)

    @staticmethod
    def clean_lens_maker(model):
        model_lower = model.lower()
        if "pentax" in model_lower: return "Pentax"
        if model_lower.startswith("hero"): return "GoPro"
        if model_lower.startswith("iphone"): return "Apple"
        if model_lower.startswith("inspire"): return "DJI"
        if model_lower.startswith("schneider"): return "Schneider-Kreuznach"
        if model_lower.startswith("phase one"): return "Phase One"
        if model_lower.startswith("venus optics"): return "Venus Optics"
        if "mitakon" in model_lower: return "Mitakon"
        if "cgo2g" in model_lower: return "Yuneec"
        if model_lower.startswith("slr magic"): return "SLR Magic"
        if model_lower.startswith("dp") and "quattro" in model_lower: return "Sigma"
        if "voigtlander" in model_lower: return "Voigtländer"
        if "handevision" in model_lower: return "HandeVision"
        maker = model.split()[0].capitalize()
        return maker

    def make_model_en_prettier(self):
        if "nikkor" in self.model_en.lower() and self.model_en.lower().startswith("nikon"):
            tokens = self.model_en.split()
            for i, token in enumerate(tokens):
                if "nikkor" in token.lower():
                    fisheye = "fisheye" in token.lower()
                    del tokens[i]
                    if fisheye:
                        if tokens[-1] == "(JPEGs)":
                            tokens.insert(-1, "Fisheye")
                        else:
                            tokens.append("Fisheye")
                    break
            try:
                dx_index = tokens.index("DX")
            except ValueError:
                pass
            else:
                del tokens[dx_index]
                for i, token in enumerate(tokens):
                    if token.startswith("f/"):
                        tokens.insert(i + 1, "DX")
                        break
            tokens[0] = "Nikkor"
            self.model_en = " ".join(tokens)
            
    def read_first_entry(self):
        entry = self.calibration_entries[0]
        camera_make = self.read_field(entry, "Make")
        self.camera_model = self.read_field(entry, "Model", camera_make)
        camera = g_lensfun_cameras.get((camera_make.lower(), self.camera_model.lower()))
        self.model_en = self.read_field(entry, "LensPrettyName")
        if self.read_field(entry, "CameraRawProfile", "True").lower() == "false":
            self.model_en += " (JPEGs)"
            self.raw = False
        else:
            self.raw = True
        self.maker = self.clean_lens_maker(self.model_en)
        try:
            self.model = self.read_field(entry, "Lens")
        except FieldNotFoundError:
            self.model = self.model_en
        if unusable_lens_name_regex.match(self.model):
            self.model = self.model_en
        self.model = LensfunLens.sanitize_lcp_lens_model_name(self.model)
        self.model_en = LensfunLens.sanitize_lcp_lens_model_name(self.model_en)
        self.make_model_en_prettier()
        try:
            self.cropfactor = float(self.read_field(entry, "SensorFormatFactor"))
        except FieldNotFoundError:
            self.cropfactor = camera and camera.cropfactor or 1
        self.fixed_lens_mount = None
        if camera:
            if camera.mount[0].islower():
                self.fixed_lens_mount = camera.mount
        elif re.search(r"coolpix|finefix|powershot|sony dsc|cyber-?shot|apple|iphone|hero|inspire|cgo2gb|samsung ex1",
                    self.model_en, re.IGNORECASE):
            self.fixed_lens_mount = "compactCamera" + str(abs(hash(self.model_en)))
            camera_element = ElementTree.Element("camera")
            ElementTree.SubElement(camera_element, "maker").text = camera_make
            ElementTree.SubElement(camera_element, "model").text = self.camera_model
            ElementTree.SubElement(camera_element, "mount").text = self.fixed_lens_mount
            ElementTree.SubElement(camera_element, "cropfactor").text = str(self.cropfactor)
            self.compact_cameras.append(camera_element)
        self.lensfun_lens = None
        models = [self.model] if self.model == self.model_en else [self.model, self.model_en]
        best_scores = (-1000, 0)
        for lens in g_lensfun_lenses:
            scores = lens.matches(models, self.cropfactor, self.fixed_lens_mount)
            if scores > best_scores:
                best_scores = scores
                self.lensfun_lens = lens
        if self.lensfun_lens:
            self.maker = child_without_attributes(self.lensfun_lens.element, "maker").text
            self.model = child_without_attributes(self.lensfun_lens.element, "model").text
        
    def fix_focal_lengths(self):
        clean_entries = []
        for entry in self.calibration_entries:
            try:
                self.read_field(entry, "FocalLength")
            except FieldNotFoundError:
                match = focal_length_regex.search(self.model)
                focal_length = None
                if match:
                    focal_length = match.group(1)
                else:
                    try:
                        match = focal_length_regex.search(self.read_field(entry, "Lens"))
                    except FieldNotFoundError:
                        if "inspire 1 fc350" in self.model.lower():
                            focal_length = 20.7
                    else:
                        if match:
                            focal_length = match.group(1)
                if focal_length:
                    if self.old_format:
                        ElementTree.SubElement(entry, camera_ns + "FocalLength").text = str(focal_length)
                        clean_entries.append(entry)
                    else:
                        entry.attrib[camera_ns + "FocalLength"] = str(focal_length)
                        clean_entries.append(entry)
                else:
                    print("Warning: No focal length could be determined for {} / {}.".format(self.maker, self.model))
                    raise NoLCPDataUsed
            else:
                clean_entries.append(entry)
        self.calibration_entries = clean_entries

    def best_entries(self, tca):
        current_distances, current_apertures, result = {}, {}, {}
        for entry in self.calibration_entries:
            perspective_entry = entry.find(camera_ns + "PerspectiveModel")
            if perspective_entry is None:
                perspective_entry = entry.find(camera_ns + "FisheyeModel")
                if perspective_entry is None:
                    continue
            if tca and self.get_description_element_maybe(perspective_entry).find(camera_ns + "ChromaticRedGreenModel") is None:
                continue
            focal_length = float(self.read_field(entry, "FocalLength"))
            current_distance = current_distances.setdefault(focal_length, -2)
            current_aperture = current_apertures.setdefault(focal_length, 1001)
            distance = float(self.read_field(entry, "FocusDistance", -1))
            if distance > current_distance:
                aperture = float(self.read_field(entry, "ApertureValue", 1000))
                if abs(aperture - 8) < abs(current_aperture - 8):
                    current_distances[focal_length] = distance
                    current_apertures[focal_length] = aperture
                    result[focal_length] = entry
        return result

    def generate_distortion_entries(self):
        best_entries = self.best_entries(tca=False)
        elements = []
        fisheye = None
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
                assert fisheye != False
                fisheye = True
            else:
                assert fisheye != True
                fisheye = False
            entry = self.get_description_element_maybe(entry)
            element = ElementTree.Element("distortion", {"focal": str(focal_length), "model": "acm"})
            for i in range(1, 6):
                k = self.read_field(entry, "RadialDistortParam{}".format(i), None)
                if k is not None:
                    element.attrib["k{}".format(i)] = k
            elements.append(element)
        return elements, fisheye

    def generate_tca_entries(self):
        best_entries = self.best_entries(tca=True)
        elements = []
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
            entry = self.get_description_element_maybe(entry)
            element = ElementTree.Element("tca", {"focal": str(focal_length), "model": "acm"})
            for type_ in ["alpha", "beta"]:
                chromatic_element = entry.find(camera_ns + ("ChromaticRedGreenModel" if type_ == "alpha" else "ChromaticBlueGreenModel"))
                scale_factor = self.read_field(chromatic_element, "ScaleFactor", None)
                if scale_factor is not None:
                    element.attrib[type_ + "0"] = scale_factor
                for i in range(1, 6):
                    parameter = self.read_field(chromatic_element, "RadialDistortParam{}".format(i), None)
                    if parameter is not None:
                        element.attrib[type_ + str(i)] = parameter
            elements.append(element)
        return elements

    def generate_vignetting_entries(self):
        match = re.search(r"f/?(?P<min>[0-9.]+)", self.model, re.IGNORECASE)
        aperture_min = float(match.group("min")) if match else 0
        elements = []
        def sort_key(entry):
            focal_length = float(self.read_field(entry, "FocalLength"))
            aperture = float(self.read_field(entry, "ApertureValue", "nan"))
            distance = float(self.read_field(entry, "FocusDistance", "nan"))
            return (focal_length, aperture, distance)
        for entry in sorted(self.calibration_entries, key=sort_key):
            focal_length = self.read_field(entry, "FocalLength")
            try:
                aperture = self.read_field(entry, "ApertureValue")
                distance = self.read_field(entry, "FocusDistance")
            except FieldNotFoundError:
                continue
            if aperture_min > float(aperture):
                continue
            entry = entry.find(camera_ns + "PerspectiveModel")
            if entry is not None:
                entry = self.get_description_element_maybe(entry)
            if entry is not None:
                entry = entry.find(camera_ns + "VignetteModel")
                if entry is not None:
                    entry = self.get_description_element_maybe(entry)
                    element = ElementTree.Element("vignetting", {"focal": focal_length, "model": "acm", "aperture": aperture, "distance": distance})
                    for i in range(1, 6):
                        alpha = self.read_field(entry, "VignetteModelParam{}".format(i), None)
                        if alpha is not None:
                            element.attrib["alpha{}".format(i)] = alpha
                    elements.append(element)
        return elements

    def guess_ilc_mounts(self):
        mounts = set()
        if self.maker == "Nikon":
            mounts.add("Nikon CX" if 2.6 < self.cropfactor < 2.8 else "Nikon F AF")
        elif self.maker == "Canon":
            mounts.add("Canon EF-M" if "ef-m" in self.model.lower() else "Canon EF")
        elif self.maker == "Sony":
            mounts.add("Sony E" if "E " in self.model else "Sony Alpha")
        elif self.maker == "Pentax":
            mounts.add("Mamiya 645" if "645" in self.model else "Pentax KAF")
        elif self.maker == "Sigma":
            mounts.add("Sony E" if "E " in self.model else "Sigma SA")
            if "E " not in self.model:
                mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Minolta AF", "Canon FD", "Olympus OM", "4/3 System"})
        elif self.maker == "Zeiss":
            mounts.add("Sony E" if "E " in self.model else "Nikon F AF")
            if "E " not in self.model:
                mounts.update({"Fujifilm X", "Canon EF", "Leica M"})
        elif self.maker == "Voigtländer":
            mounts.update({"DKL", "Leica M", "M42", "Micro 4/3 System", "Nikon F"})
        elif self.maker == "Leica":
            if "-S " in self.model or " S " in self.model: mounts.add("Leica S")
            elif "-R " in self.model or " R " in self.model: mounts.add("Leica R")
            else: mounts.add("Leica M")
        elif self.maker == "Mamiya": mounts.add("Mamiya 645")
        elif self.maker == "Tokina": mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Canon FD", "Minolta M", "Olympus OM"})
        elif self.maker == "Tamron": mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF"})
        elif self.maker == "Samsung":
            if "NX" in self.model or "NX" in self.camera_model: mounts.add("Samsung NX")
        elif self.maker == "HandeVision":
            mounts.add("Sony E" if "E " in self.model else "Canon EF-M")
            if "E " not in self.model: mounts.update({"Micro 4/3 System", "Fujifilm X"})
        elif self.maker == "SLR Magic": mounts.update({"Leica M", "Sony E", "Micro 4/3 System", "Fujifilm X"})
        elif self.maker == "Hasselblad":
            mounts.add("Sony E" if "LF" in self.model else "Hasselblad H")
        elif self.maker == "Mitakon": mounts.update({"Sony E", "Micro 4/3 System", "Fujifilm X", "Canon EF", "Nikon F AI"})
        elif self.maker == "Venus Optics": mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF"})
        elif self.maker == "Schneider-Kreuznach":
            if "phase one" in self.camera_model.lower(): mounts.update({"Hasselblad H", "Mamiya 645"})
        elif self.maker == "Phase One": mounts.update({"Hasselblad H", "Mamiya 645"})
        elif self.maker == "Lomography": mounts.update({"Nikon F AF", "Canon EF"})
        if not mounts:
            print("Warning: Fall back to default mounts for {} / {}.".format(self.maker, self.model))
            mounts = {"Sigma SA", "Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Minolta AF", "Canon FD", "Olympus OM", "4/3 System"}
        elements = []
        for mount in mounts:
            element = ElementTree.Element("mount")
            element.text = mount
            elements.append(element)
        return elements

    def xml_element(self):
        if self.lensfun_lens:
            lens = copy.deepcopy(self.lensfun_lens.element)
            calibration = lens.find("calibration")
            if calibration is None:
                calibration = ElementTree.SubElement(lens, "calibration")
            lcp_entries_used = False
            if calibration.find("distortion") is None or g_args.prefer_lcp:
                entries, fisheye = self.generate_distortion_entries()
                if entries:
                    type_ = lens.find("type")
                    if fisheye:
                        if type_ is not None: type_.text = "fisheye"
                        else: lens.insert(max(len(lens) - 1, 0), ElementTree.Element("type", text="fisheye"))
                    elif type_ is not None:
                        lens.remove(type_)
                    for entry in calibration.findall("distortion"): calibration.remove(entry)
                    calibration.extend(entries)
                    lcp_entries_used = True
            if calibration.find("tca") is None or g_args.prefer_lcp:
                entries = self.generate_tca_entries()
                if entries:
                    for entry in calibration.findall("tca"): calibration.remove(entry)
                    calibration.extend(entries)
                    lcp_entries_used = True
            if calibration.find("vignetting") is None or g_args.prefer_lcp:
                entries = self.generate_vignetting_entries()
                if entries:
                    for entry in calibration.findall("vignetting"): calibration.remove(entry)
                    calibration.extend(entries)
                    lcp_entries_used = True
            if not lcp_entries_used:
                raise NoLCPDataUsed
        else:
            lens = ElementTree.Element("lens")
            ElementTree.SubElement(lens, "maker").text = self.maker
            ElementTree.SubElement(lens, "model").text = self.model
            if self.fixed_lens_mount:
                suffix = "" if self.raw else " (JPEGs)"
                ElementTree.SubElement(lens, "model", lang="en").text = "fixed lens" + suffix
                ElementTree.SubElement(lens, "model", lang="de").text = "festes Objektiv" + suffix
                ElementTree.SubElement(lens, "mount").text = self.fixed_lens_mount
            else:
                if self.model != self.model_en:
                    ElementTree.SubElement(lens, "model", {"lang": "en"}).text = self.model_en
                lens.extend(self.guess_ilc_mounts())
            ElementTree.SubElement(lens, "cropfactor").text = str(self.cropfactor)
            entries, fisheye = self.generate_distortion_entries()
            if fisheye:
                ElementTree.SubElement(lens, "type").text = "fisheye"
            calibration = ElementTree.SubElement(lens, "calibration")
            if entries: calibration.extend(entries)
            entries = self.generate_tca_entries()
            if entries: calibration.extend(entries)
            entries = self.generate_vignetting_entries()
            if entries: calibration.extend(entries)
        
        self.correction_coverage = 0
        if calibration.find("distortion") is not None: self.correction_coverage += 1
        if calibration.find("tca") is not None: self.correction_coverage += 1
        if calibration.find("vignetting") is not None: self.correction_coverage += 1
        if not self.correction_coverage:
            print("Warning: LCP file for {} / {} contained no correction data.".format(self.maker, self.model))
            raise NoLCPDataUsed
        return lens

    @property
    def normalized_cropfactor(self):
        if 1.5 <= self.cropfactor <= 1.57: return 1.5
        elif 1.58 <= self.cropfactor <= 1.63: return 1.6
        elif 1.2 <= self.cropfactor <= 1.3: return 1.3
        else: return round(self.cropfactor * 10) / 10

def read_lcp_file(filepath):
    """Worker function to read and parse a single LCP file."""
    try:
        return LCPLens(filepath)
    except (ElementTree.ParseError, NoLCPDataUsed, IndexError, ValueError) as e:
        # IndexError can happen with malformed LCP files, e.g. tree.getroot()[0][0][0][0]
        # ValueError can happen on float conversions
        print(f"Skipping {filepath} due to parsing error: {type(e).__name__}: {e}")
        return None

def main():
    parser = argparse.ArgumentParser(description="Convert LCP files to a Lensfun XML file.")
    parser.add_argument("input_directory", default=".", nargs="?", metavar="path",
                        help="""path to the LCP files (default: ".")""")
    parser.add_argument("--output", default=os.path.expanduser("~/.local/share/lensfun/_lcps.xml"),
                        help="Path of output file (default: ~/.local/share/lensfun/_lcps.xml). This file is overwritten silently.")
    parser.add_argument("--db-path", help="Path to the lensfun database. If not given, look in the same places as Lensfun.")
    parser.add_argument("--prefer-lcp", action="store_true", help="Prefer LCP data over Lensfun data.")
    local_args = parser.parse_args()

    def indent(elem, level=0):
        i = "\n" + level * "    "
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = i + "    "
            for elem in elem:
                indent(elem, level + 1)
                if level == 0:
                    elem.tail = "\n" + i + "    "
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
        else:
            if level and (not elem.tail or not elem.tail.strip()):
                elem.tail = i

    def read_lensfun_database():
        lensfun_cameras = {}
        lensfun_lenses_dict = {}
        def crawl_directory(dirpath):
            if not os.path.isdir(dirpath): return
            for filepath in glob.glob(os.path.join(dirpath, "*.xml")):
                if not os.path.basename(filepath).startswith("_"):
                    try:
                        tree = ElementTree.parse(filepath).getroot()
                        for element in tree.findall("camera"):
                            maker_elem = child_without_attributes(element, "maker")
                            model_elem = child_without_attributes(element, "model")
                            if maker_elem is not None and model_elem is not None:
                                maker, model = maker_elem.text, model_elem.text
                                lensfun_cameras[maker.lower(), model.lower()] = camera = LensfunCamera(maker, model)
                                camera.cropfactor = float(element.find("cropfactor").text)
                                camera.mount = element.find("mount").text
                        for element in tree.findall("lens"):
                            lens = LensfunLens(element)
                            lensfun_lenses_dict[lens.normalized_model, lens.cropfactor] = lens
                    except ElementTree.ParseError:
                        print(f"Warning: Could not parse Lensfun DB file: {filepath}")

        paths_search_list = [local_args.db_path] if local_args.db_path else \
                            ["/usr/share/lensfun", "/usr/local/share/lensfun", "/var/lib/lensfun-updates",
                            os.path.expanduser("~/.local/share/lensfun/updates"),
                            os.path.expanduser("~/.local/share/lensfun")]
        for path in paths_search_list:
            crawl_directory(path)
        return lensfun_cameras, set(lensfun_lenses_dict.values())

    local_lensfun_cameras, local_lensfun_lenses = read_lensfun_database()
    if not local_lensfun_cameras and not local_lensfun_lenses:
        print("Warning: No Lensfun database found.")

    def read_lcp_files():
        pool = multiprocessing.Pool(initializer=init_worker, initargs=(local_lensfun_cameras, local_lensfun_lenses, local_args))
        filepaths = []
        for root, __, filenames in os.walk(local_args.input_directory):
            for filename in filenames:
                if filename.lower().endswith('.lcp'):
                    filepaths.append(os.path.join(root, filename))
        
        results = pool.map(read_lcp_file, filepaths)
        pool.close()
        pool.join()

        lcp_lenses_dict = {}
        for lcp_lens in results:
            if lcp_lens:
                key = (lcp_lens.maker, lcp_lens.model, lcp_lens.normalized_cropfactor)
                already_existing_lens = lcp_lenses_dict.get(key)
                if not already_existing_lens or \
                   already_existing_lens.correction_coverage < lcp_lens.correction_coverage or \
                   (already_existing_lens.correction_coverage == lcp_lens.correction_coverage and already_existing_lens.cropfactor > lcp_lens.cropfactor):
                    lcp_lenses_dict[key] = lcp_lens
        return set(lcp_lenses_dict.values())

    lcp_lenses = read_lcp_files()

    output = ElementTree.Element("lensdatabase", {"version": "2"})
    for camera in LCPLens.compact_cameras:
        output.append(camera)
    for lens in lcp_lenses:
        output.append(lens.xml_element)
    indent(output)
    if len(output):
        output.text = "\n\n    "
        output.tail = "\n"
        output[-1].tail = "\n\n"
    
    output_dir = os.path.dirname(local_args.output)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
        
    with open(local_args.output, "w", encoding="utf-8") as f:
        f.write(ElementTree.tostring(output, encoding="unicode"))

if __name__ == '__main__':
    multiprocessing.freeze_support()
    main()